# Сервис автоматического назначения ревьюеров

Этот сервис автоматически назначает ревьюеров на Pull Request (PR) внутри команды. Он предоставляет удобный HTTP API для управления командами, пользователями, PR и ревьюерами, обеспечивая автоматическое назначение при создании PR, переназначение ревьюеров и корректное выполнение merge.

---

## Требования

* Docker и Docker Compose


---

## Переменные окружения

Переменные окружения указаны  в `.env`. Этот файл присутствует на github в качестве исключения для удобной проверки

---

## Сборка и запуск

1. Клонируйте репозиторий..
3. Запустите проект:

```bash
docker-compose up --build


Это поднимет два сервиса:

* postgres — контейнер PostgreSQL с автоматическим применением миграций.
* backend — Go-сервис, работающий на порту 8000.

*Возможная ошибка: на машине будет работать хостовый postgresql. Поэтому сперва нужно освободить порт.
Для Linux: sudo systemctl stop postgresql
```

---

## API

Сервис предоставляет следующие HTTP-эндпоинты:

### Управление командами

* POST /team/add — создать команду
* GET /team/get — получить информацию о команде

### Управление пользователями

* POST /users/setIsActive — включить/выключить пользователя
* GET /users/getReview — получить список PR, назначенных пользователю

### Управление Pull Request

* POST /pullRequest/create — создать PR (ревьюеры назначаются автоматически)
* POST /pullRequest/merge — слить PR (идемпотентно)
* POST /pullRequest/reassign — переназначить ревьюера

### Статистика

* GET /statistic/get — получить базовую статистику (например, количество назначений)

Полное описание API — в файле openapi.yaml

---

## Дополнительные сведения

* Backend работает на порту 8000.
* При создании PR назначаются до двух активных ревьюеров из команды автора, кроме самого автора.
* После merge ревьюеров менять нельзя.
* Пользователи с isActive = false не участвуют в назначении ревьюеров.
* Миграции базы данных применяются автоматически.


---

## Разработка

* Был написан монолит с использованием 3х слойной архитектуры: хэндлеры, сервисы с бизнес логикой,репозиторий для работы с бд. Чтобы связать эти три слоя воедино был использован такой паттерн проектирования как dependency injection, также был использован gorm в качестве orm. Ошибки обрабатывались стандартным способом в go когда функция возвращает значение и ошибку
* Конфигурация линтеров находится в .golangci.yml.
* статитика собирается по users и pull_requests
---
## Структура проекта

```text
internal/
├── config/          # Загрузка переменных окружения (.env)
├── delivery/        # HTTP-обработчики (Gin)
├── repository/      # Работа с базой данных (GORM)
├── schemas/         # Модели БД и DTO для API
├── service/         # Бизнес-логика
pkg/
└── errors/          # Кастомные ошибки приложения
cmd/app/             # Точка входа (main.go)
```
---

## Стек

* База данных — PostgreSQL.
* Код написан на GO полностью
* Запуск/контейнеризация - docker/docker-compose

---
